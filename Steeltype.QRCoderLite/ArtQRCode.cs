using SkiaSharp;
using static Steeltype.QRCoderLite.ArtQRCode;

// pull request raised to extend library used. 
namespace Steeltype.QRCoderLite
{
    public class ArtQRCode : AbstractQRCode, IDisposable
    {
        /// <summary>
        /// Constructor without params to be used in COM Objects connections
        /// </summary>
        public ArtQRCode() { }

        /// <summary>
        /// Creates new ArtQrCode object
        /// </summary>
        /// <param name="data">QRCodeData generated by the QRCodeGenerator</param>
        public ArtQRCode(QRCodeData data) : base(data) { }

        /// <summary>
        /// Renders an art-style QR code with dots as modules. (With default settings: DarkColor=Black, LightColor=White, Background=Transparent, QuietZone=true)
        /// </summary>
        /// <param name="pixelsPerModule">Amount of px each dark/light module of the QR code shall take place in the final QR code image</param>
        /// <returns>QRCode graphic as bitmap</returns>
        public SKBitmap GetGraphic(int pixelsPerModule)
        {
            return GetGraphic(pixelsPerModule, SKColors.Black, SKColors.White, SKColors.Transparent);
        }

        /// <summary>
        /// Renders an art-style QR code with dots as modules and a background image (With default settings: DarkColor=Black, LightColor=White, Background=Transparent, QuietZone=true)
        /// </summary>
        /// <param name="backgroundImage">A bitmap object that will be used as background picture</param>
        /// <returns>QRCode graphic as bitmap</returns>
        public SKBitmap GetGraphic(SKBitmap backgroundImage = null)
        {
            return GetGraphic(10, SKColors.Black, SKColors.White, SKColors.Transparent, backgroundImage: backgroundImage);
        }

        /// <summary>
        /// Renders an art-style QR code with dots as modules and various user settings
        /// </summary>
        /// <param name="pixelsPerModule">Amount of px each dark/light module of the QR code shall take place in the final QR code image</param>
        /// <param name="darkColor">Color of the dark modules</param>
        /// <param name="lightColor">Color of the light modules</param>
        /// <param name="backgroundColor">Color of the background</param>
        /// <param name="backgroundImage">A bitmap object that will be used as background picture</param>
        /// <param name="pixelSizeFactor">Value between 0.0 to 1.0 that defines how big the module dots are. The bigger the value, the less round the dots will be.</param>
        /// <param name="drawQuietZones">If true a white border is drawn around the whole QR Code</param>
        /// <param name="quietZoneRenderingStyle">Style of the quiet zones</param>
        /// <param name="backgroundImageStyle">Style of the background image (if set). Fill=spanning complete graphic; DataAreaOnly=Don't paint background into quiet zone</param>
        /// <param name="finderPatternImage">Optional image that should be used instead of the default finder patterns</param>
        /// <returns>QRCode graphic as bitmap</returns>
        public SKBitmap GetGraphic(int pixelsPerModule, SKColor darkColor, SKColor lightColor, SKColor backgroundColor, SKBitmap backgroundImage = null, double pixelSizeFactor = 0.8,
                                   bool drawQuietZones = true, QuietZoneStyle quietZoneRenderingStyle = QuietZoneStyle.Dotted,
                                   BackgroundImageStyle backgroundImageStyle = BackgroundImageStyle.DataAreaOnly, SKBitmap finderPatternImage = null)
        {
            if (pixelSizeFactor > 1)
                throw new Exception("The parameter pixelSize must be between 0 and 1. (0-100%)");
            var pixelSize = (int)Math.Min(pixelsPerModule, Math.Floor(pixelsPerModule * pixelSizeFactor));

            var numModules = QrCodeData.ModuleMatrix.Count - (drawQuietZones ? 0 : 8);
            var offset = (drawQuietZones ? 0 : 4);
            var size = numModules * pixelsPerModule;

            var bitmap = new SKBitmap(size, size);
            using var canvas = new SKCanvas(bitmap);
            canvas.Clear(backgroundColor); // Set background color

            // Render background if set
            if (backgroundImage != null)
            {
                var backgroundDestRect = backgroundImageStyle == BackgroundImageStyle.Fill
                    ? new SKRect(0, 0, size, size)
                    : new SKRect(offset * pixelsPerModule, offset * pixelsPerModule, size - offset * pixelsPerModule, size - offset * pixelsPerModule);

                var resizedBackgroundImage = Resize(backgroundImage, size);
                canvas.DrawBitmap(resizedBackgroundImage, backgroundDestRect);
            }

            // Prepare dot pixel images
            var darkModulePixel = MakeDotPixel(pixelsPerModule, pixelSize, darkColor);
            var lightModulePixel = MakeDotPixel(pixelsPerModule, pixelSize, lightColor);

            for (var x = 0; x < numModules; x++)
            {
                for (var y = 0; y < numModules; y++)
                {
                    var rectangle = new SKRect(x * pixelsPerModule, y * pixelsPerModule, (x + 1) * pixelsPerModule, (y + 1) * pixelsPerModule);
                    var pixelIsDark = QrCodeData.ModuleMatrix[offset + y][offset + x];
                    var pixelImage = pixelIsDark ? darkModulePixel : lightModulePixel;

                    if (!IsPartOfFinderPattern(x, y, numModules, offset))
                    {
                        if (drawQuietZones && quietZoneRenderingStyle == QuietZoneStyle.Flat && IsPartOfQuietZone(x, y, numModules))
                            canvas.DrawRect(rectangle, new SKPaint { Color = pixelIsDark ? darkColor : lightColor });
                        else
                            canvas.DrawBitmap(pixelImage, rectangle.Left, rectangle.Top);
                    }
                    else if (finderPatternImage == null)
                        canvas.DrawRect(rectangle, new SKPaint { Color = pixelIsDark ? darkColor : lightColor });
                }
            }

            // Draw finder pattern images if provided
            if (finderPatternImage != null)
            {
                var finderPatternSize = 7 * pixelsPerModule;
                var finderPatternDestRects = new SKRect[]
                {
                    new(0, 0, finderPatternSize, finderPatternSize),
                    new(size - finderPatternSize, 0, finderPatternSize, finderPatternSize),
                    new(0, size - finderPatternSize, finderPatternSize, finderPatternSize)
                };
                foreach (var rect in finderPatternDestRects)
                {
                    canvas.DrawBitmap(finderPatternImage, rect);
                }
            }

            return bitmap;
        }

        /// <summary>
        /// If the pixelSize is bigger than the pixelsPerModule or may end up filling the Module making a traditional QR code.
        /// </summary>
        /// <param name="pixelsPerModule">Pixels used per module rendered</param>
        /// <param name="pixelSize">Size of the dots</param>
        /// <param name="color">Color of the pixels</param>
        /// <returns></returns>
        private SKBitmap MakeDotPixel(int pixelsPerModule, int pixelSize, SKColor color)
        {
            // Draw a dot
            var bitmap = new SKBitmap(pixelSize, pixelSize);
            using (var canvas = new SKCanvas(bitmap))
            {
                var paint = new SKPaint
                {
                    Color = color,
                    IsAntialias = true, // Enable anti-aliasing for smoother edges
                    Style = SKPaintStyle.Fill // Ensure the ellipse is filled
                };

                // Draw filled ellipse
                canvas.DrawOval(new SKRect(0, 0, pixelSize, pixelSize), paint);
            }

            var pixelWidth = Math.Min(pixelsPerModule, pixelSize);
            var margin = Math.Max((pixelsPerModule - pixelWidth) / 2, 0);

            // Center the dot in the module and crop to stay the right size.
            var cropped = new SKBitmap(pixelsPerModule, pixelsPerModule);
            using (var canvas = new SKCanvas(cropped))
            {
                // Clear the background to transparent or a specific color if needed
                canvas.Clear(SKColors.Transparent);

                // Calculate source and destination rectangles for cropping and centering
                var srcRect = new SKRect((pixelSize - pixelWidth) / 2, (pixelSize - pixelWidth) / 2, (pixelSize + pixelWidth) / 2, (pixelSize + pixelWidth) / 2);
                var destRect = new SKRect(margin, margin, margin + pixelWidth, margin + pixelWidth);

                // Draw the cropped and centered dot
                canvas.DrawBitmap(bitmap, srcRect, destRect);
            }

            return cropped;
        }

        /// <summary>
        /// Checks if a given module(-position) is part of the quiet zone of a QR code
        /// </summary>
        /// <param name="x">X position</param>
        /// <param name="y">Y position</param>
        /// <param name="numModules">Total number of modules per row</param>
        /// <returns>true, if position is part of quiet zone</returns>
        private static bool IsPartOfQuietZone(int x, int y, int numModules)
        {
            return
                x < 4 || //left 
                y < 4 || //top
                x > numModules - 5 || //right
                y > numModules - 5; //bottom                
        }


        /// <summary>
        /// Checks if a given module(-position) is part of one of the three finder patterns of a QR code
        /// </summary>
        /// <param name="x">X position</param>
        /// <param name="y">Y position</param>
        /// <param name="numModules">Total number of modules per row</param>
        /// <param name="offset">Offset in modules (usually depending on drawQuietZones parameter)</param>
        /// <returns>true, if position is part of any finder pattern</returns>
        private static bool IsPartOfFinderPattern(int x, int y, int numModules, int offset)
        {
            var cornerSize = 11 - offset;
            var outerLimitLow = (numModules - cornerSize - 1);
            var outerLimitHigh = outerLimitLow + 8;
            var invertedOffset = 4 - offset;
            return
                (x >= invertedOffset && x < cornerSize && y >= invertedOffset && y < cornerSize) || //Top-left finder pattern
                (x > outerLimitLow && x < outerLimitHigh && y >= invertedOffset && y < cornerSize) || //Top-right finder pattern
                (x >= invertedOffset && x < cornerSize && y > outerLimitLow && y < outerLimitHigh); //Bottom-left finder pattern
        }

        /// <summary>
        /// Resize to a square bitmap, but maintain the aspect ratio by padding transparently.
        /// </summary>
        /// <param name="image"></param>
        /// <param name="newSize"></param>
        /// <returns>Resized image as bitmap</returns>
        private static SKBitmap Resize(SKBitmap image, int newSize)
        {
            if (image == null) return null;

            var scale = Math.Min((float)newSize / image.Width, (float)newSize / image.Height);
            var scaledWidth = (int)(image.Width * scale);
            var scaledHeight = (int)(image.Height * scale);
            var offsetX = (newSize - scaledWidth) / 2;
            var offsetY = (newSize - scaledHeight) / 2;

            // Create a new SKBitmap for the scaled image
            var scaledImage = new SKBitmap(scaledWidth, scaledHeight);
            using (var canvas = new SKCanvas(scaledImage))
            {
                canvas.Clear(SKColors.Transparent);
                using var paint = new SKPaint
                {
                    IsAntialias = true,
                    FilterQuality = SKFilterQuality.High // Ensures high-quality scaling
                };
                var sourceRect = new SKRect(0, 0, image.Width, image.Height);
                var destRect = new SKRect(0, 0, scaledWidth, scaledHeight);
                canvas.DrawBitmap(image, sourceRect, destRect, paint);
            }

            // Create a new SKBitmap for the final resized image with padding
            var resizedImage = new SKBitmap(newSize, newSize);
            using (var canvas = new SKCanvas(resizedImage))
            {
                canvas.Clear(SKColors.Transparent);
                var targetRect = new SKRect(offsetX, offsetY, offsetX + scaledWidth, offsetY + scaledHeight);
                canvas.DrawBitmap(scaledImage, targetRect);
            }

            return resizedImage;
        }


        /// <summary>
        /// Defines how the quiet zones shall be rendered.
        /// </summary>
        public enum QuietZoneStyle
        {
            Dotted,
            Flat
        }

        /// <summary>
        /// Defines how the background image (if set) shall be rendered.
        /// </summary>
        public enum BackgroundImageStyle
        {
            Fill,
            DataAreaOnly
        }
    }

    public static class ArtQRCodeHelper
    {
        /// <summary>
        /// Helper function to create an ArtQRCode graphic with a single function call
        /// </summary>
        /// <param name="plainText">Text/payload to be encoded inside the QR code</param>
        /// <param name="pixelsPerModule">Amount of px each dark/light module of the QR code shall take place in the final QR code image</param>
        /// <param name="darkColor">Color of the dark modules</param>
        /// <param name="lightColor">Color of the light modules</param>
        /// <param name="backgroundColor">Color of the background</param>
        /// <param name="eccLevel">The level of error correction data</param>
        /// <param name="forceUtf8">Shall the generator be forced to work in UTF-8 mode?</param>
        /// <param name="utf8BOM">Should the byte-order-mark be used?</param>
        /// <param name="eciMode">Which ECI mode shall be used?</param>
        /// <param name="requestedVersion">Set fixed QR code target version.</param>
        /// <param name="backgroundImage">A bitmap object that will be used as background picture</param>
        /// <param name="pixelSizeFactor">Value between 0.0 to 1.0 that defines how big the module dots are. The bigger the value, the less round the dots will be.</param>
        /// <param name="drawQuietZones">If true a white border is drawn around the whole QR Code</param>
        /// <param name="quietZoneRenderingStyle">Style of the quiet zones</param>
        /// <param name="backgroundImageStyle">Style of the background image (if set). Fill=spanning complete graphic; DataAreaOnly=Don't paint background into quietzone</param>
        /// <param name="finderPatternImage">Optional image that should be used instead of the default finder patterns</param>
        /// <returns>QRCode graphic as bitmap</returns>
        public static SKBitmap GetQRCode(string plainText, int pixelsPerModule, SKColor darkColor, SKColor lightColor, SKColor backgroundColor, QRCodeGenerator.ECCLevel eccLevel, bool forceUtf8 = false,
                                       bool utf8BOM = false, QRCodeGenerator.EciMode eciMode = QRCodeGenerator.EciMode.Default, int requestedVersion = -1, SKBitmap backgroundImage = null, double pixelSizeFactor = 0.8,
                                       bool drawQuietZones = true, QuietZoneStyle quietZoneRenderingStyle = QuietZoneStyle.Flat,
                                       BackgroundImageStyle backgroundImageStyle = BackgroundImageStyle.DataAreaOnly, SKBitmap finderPatternImage = null)
        {
            using var qrGenerator = new QRCodeGenerator();
            using var qrCodeData = qrGenerator.CreateQrCode(plainText, eccLevel, forceUtf8, utf8BOM, eciMode, requestedVersion);
            using var qrCode = new ArtQRCode(qrCodeData);
            return qrCode.GetGraphic(pixelsPerModule, darkColor, lightColor, backgroundColor, backgroundImage, pixelSizeFactor, drawQuietZones, quietZoneRenderingStyle, backgroundImageStyle, finderPatternImage);
        }
    }
}